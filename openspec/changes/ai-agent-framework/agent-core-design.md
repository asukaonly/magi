# Agent Coreï¼ˆä¸‰å±‚Agentæ¶æ„ï¼‰å®Œæ•´è®¾è®¡

## æ ¸å¿ƒæ¶æ„

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ç¬¬ä¸€å±‚ï¼šMaster Agentï¼ˆä¸»Agentï¼‰            â”‚
â”‚  - ä»»åŠ¡è¯†åˆ«ä¸åˆ†å‘                          â”‚
â”‚  - ç³»ç»Ÿç›‘æ§ä¸è‡ªæ„ˆ                          â”‚
â”‚  - ä»»åŠ¡æ•°æ®åº“ç®¡ç†                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â†“ åˆ›å»ºä»»åŠ¡
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ä»»åŠ¡æ•°æ®åº“ï¼ˆTask Databaseï¼‰                â”‚
â”‚  - æŒä¹…åŒ–ä»»åŠ¡é˜Ÿåˆ—                           â”‚
â”‚  - ä»»åŠ¡çŠ¶æ€è·Ÿè¸ª                             â”‚
â”‚  - ä¼˜å…ˆçº§è°ƒåº¦                               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â†“ æ‰«æä»»åŠ¡
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ç¬¬äºŒå±‚ï¼šTaskAgentï¼ˆå›ºå®šæ•°é‡ï¼Œé…ç½®åŒ–ï¼‰      â”‚
â”‚  - ä»»åŠ¡è¯†åˆ«ä¸æ‹†è§£                          â”‚
â”‚  - è®°å¿†å’Œå·¥å…·åŒ¹é…                          â”‚
â”‚  - å­ä»»åŠ¡ç¼–æ’ä¸è¶…æ—¶æ§åˆ¶                    â”‚
â”‚  - WorkerAgentç”Ÿå‘½å‘¨æœŸç®¡ç†                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                    â†“ åˆ›å»ºWorker
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ç¬¬ä¸‰å±‚ï¼šWorkerAgentï¼ˆæ— çŠ¶æ€ï¼Œç”¨å®Œå³é”€ï¼‰   â”‚
â”‚  - è½»é‡çº§æ‰§è¡Œå•å…ƒ                           â”‚
â”‚  - æ¥æ”¶è®°å¿†ã€å·¥å…·ã€è¾“å…¥                      â”‚
â”‚  - æ‰§è¡Œå¹¶è¾“å‡º                               â”‚
â”‚  - ç‹¬ç«‹è¶…æ—¶æ§åˆ¶                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 1. Master Agentï¼ˆä¸»Agentï¼‰

### æ ¸å¿ƒèŒè´£
1. **ä»»åŠ¡è¯†åˆ«**ï¼šä»æ„ŸçŸ¥è¾“å…¥ä¸­è¯†åˆ«ä»»åŠ¡
2. **ä»»åŠ¡åˆ†å‘**ï¼šå°†ä»»åŠ¡è®°å½•åˆ°æ•°æ®åº“
3. **ç³»ç»Ÿç›‘æ§**ï¼šç›‘æ§ç³»ç»Ÿå¥åº·çŠ¶æ€
4. **å¼‚å¸¸æ¢å¤**ï¼šé‡å¯å¼‚å¸¸çš„TaskAgent
5. **å†…åŠ¡ç®¡ç†**ï¼šå‘¨æœŸæ€§ç»´æŠ¤ä»»åŠ¡ï¼ˆæ•´ç†è®°å¿†ç­‰ï¼‰

### å®Œæ•´å®ç°

```python
class MasterAgent:
    """ä¸»Agent - ç³»ç»Ÿç®¡ç†ä¸ä»»åŠ¡åˆ†å‘"""

    def __init__(self, config: AgentConfig):
        self.config = config
        self.state = AgentState.IDLE
        self.llm = config.llm

        # æ ¸å¿ƒç»„ä»¶
        self.perception_manager = PerceptionManager(config.perception)
        self.task_database = TaskDatabase(config.database)
        self.system_monitor = SystemMonitor()

        # TaskAgentç®¡ç†ï¼ˆå›ºå®šæ•°é‡ï¼Œä»é…ç½®è¯»å–ï¼‰
        self.task_agents: Dict[str, TaskAgent] = {}
        self.num_task_agents = config.get("num_task_agents", 3)

        # WorkerAgentè·Ÿè¸ªï¼ˆç”¨äºè¶…æ—¶æ¸…ç†ï¼‰
        self.worker_agents: Dict[str, WorkerInfo] = {}

    async def start(self):
        """å¯åŠ¨ä¸»Agent"""
        logger.info("Master Agent å¯åŠ¨ä¸­...")
        self.state = AgentState.INITIALIZING

        # 1. å¯åŠ¨ç³»ç»Ÿç›‘æ§
        await self.system_monitor.start()

        # 2. å¯åŠ¨æ„ŸçŸ¥å™¨
        await self.perception_manager.start()

        # 3. åˆå§‹åŒ–ä»»åŠ¡æ•°æ®åº“
        await self.task_database.initialize()

        # 4. å¯åŠ¨å›ºå®šæ•°é‡çš„TaskAgent
        for i in range(self.num_task_agents):
            task_agent = TaskAgent(
                id=f"task_agent_{i}",
                config=self.config,
                task_database=self.task_database,
                master_agent=self  # å¼•ç”¨ï¼Œç”¨äºå¼‚å¸¸é€šçŸ¥
            )
            await task_agent.start()
            self.task_agents[task_agent.id] = task_agent

        # 5. å¯åŠ¨å†…åŠ¡ä»»åŠ¡ï¼ˆå‘¨æœŸæ€§æ•´ç†è®°å¿†ç­‰ï¼‰
        asyncio.create_task(self._internal_tasks_loop())

        # 6. è¿›å…¥ä¸»å¾ªç¯
        self.state = AgentState.RUNNING
        await self._main_loop()

    async def _main_loop(self):
        """ä¸»å¾ªç¯"""
        while self.state == AgentState.RUNNING:
            try:
                # 1. è·å–æ„ŸçŸ¥è¾“å…¥
                perceptions = await self.perception_manager.perceive()

                # 2. ä»»åŠ¡è¯†åˆ«
                for perception in perceptions:
                    tasks = await self._recognize_tasks(perception)

                    # 3. è®°å½•åˆ°ä»»åŠ¡æ•°æ®åº“
                    for task in tasks:
                        await self.task_database.add(task)

                        logger.info(
                            f"ä»»åŠ¡å·²åˆ›å»º: {task.id}, "
                            f"ç±»å‹: {task.type}, "
                            f"ä¼˜å…ˆçº§: {task.priority}"
                        )

                # 4. ç³»ç»Ÿç›‘æ§æ£€æŸ¥
                await self._check_system_health()

                # 5. çŸ­æš‚ä¼‘çœ 
                await asyncio.sleep(0.1)

            except Exception as e:
                logger.error(f"ä¸»å¾ªç¯å¼‚å¸¸: {e}", exc_info=True)
                await asyncio.sleep(1)  # å¼‚å¸¸åä¼‘çœ å†ç»§ç»­

    async def _recognize_tasks(
        self,
        perception: Perception
    ) -> List[Task]:
        """ä»æ„ŸçŸ¥è¾“å…¥è¯†åˆ«ä»»åŠ¡"""

        tasks = []

        try:
            # æ ¹æ®æ„ŸçŸ¥ç±»å‹è¯†åˆ«
            if perception.type == PerceptionType.TEXT:
                # ç”¨æˆ·æ¶ˆæ¯ â†’ å¯èƒ½æ˜¯ç”¨æˆ·ä»»åŠ¡
                user_task = await self._recognize_user_task(perception)
                if user_task:
                    tasks.append(user_task)

            elif perception.type == PerceptionType.EVENT:
                # äº‹ä»¶ â†’ å¯èƒ½æ˜¯å‘¨æœŸæ€§ä»»åŠ¡
                event_task = await self._recognize_event_task(perception)
                if event_task:
                    tasks.append(event_task)

            # å†…åœ¨ä»»åŠ¡ï¼ˆæ•´ç†è®°å¿†ç­‰ï¼‰
            internal_tasks = await self._generate_internal_tasks()
            tasks.extend(internal_tasks)

        except Exception as e:
            logger.error(f"ä»»åŠ¡è¯†åˆ«å¼‚å¸¸: {e}")

        return tasks

    async def _recognize_user_task(
        self,
        perception: Perception
    ) -> Optional[Task]:
        """è¯†åˆ«ç”¨æˆ·ä»»åŠ¡"""

        try:
            prompt = f"""
            ç”¨æˆ·è¾“å…¥ï¼š{perception.data}

            è¯·åˆ¤æ–­è¿™æ˜¯ä¸€ä¸ªç”¨æˆ·ä»»åŠ¡å—ï¼Ÿ
            å¦‚æœæ˜¯ï¼Œæå–ï¼š
            1. ä»»åŠ¡æè¿°
            2. ä»»åŠ¡ç±»å‹ï¼ˆå¦‚ï¼šinformation_retrieval, communication, task_executionç­‰ï¼‰
            3. ä¼˜å…ˆçº§ï¼ˆ0-5ï¼Œ5æœ€é«˜ï¼‰
            4. æ˜¯å¦éœ€è¦ç”¨æˆ·äº¤äº’

            æ ¼å¼ï¼šJSON
            {{
                "is_task": true/false,
                "description": "ä»»åŠ¡æè¿°",
                "type": "information_retrieval",
                "priority": 3,
                "requires_user_interaction": false
            }}
            """

            response = await self.llm.generate(prompt)
            result = json.loads(response)

            if result.get("is_task", False):
                return Task(
                    id=str(uuid.uuid4()),
                    type=result["type"],
                    description=result["description"],
                    priority=result.get("priority", 3),
                    source="user",
                    requires_user_interaction=result.get("requires_user_interaction", False),
                    metadata={"perception_id": perception.id}
                )

        except Exception as e:
            logger.error(f"ç”¨æˆ·ä»»åŠ¡è¯†åˆ«å¤±è´¥: {e}")

        return None

    async def _recognize_event_task(
        self,
        perception: Perception
    ) -> Optional[Task]:
        """è¯†åˆ«äº‹ä»¶ä»»åŠ¡"""

        # äº‹ä»¶ç±»å‹ä»»åŠ¡é€šå¸¸æœ‰æ˜ç¡®çš„è§¦å‘æ¡ä»¶
        event_data = perception.data

        # æ£€æŸ¥æ˜¯å¦æ˜¯å®šæ—¶ä»»åŠ¡
        if "schedule" in event_data:
            return Task(
                id=str(uuid.uuid4()),
                type="scheduled_task",
                description=event_data.get("description"),
                priority=event_data.get("priority", 2),
                source="event",
                schedule=event_data.get("schedule"),
                metadata=event_data
            )

        return None

    async def _generate_internal_tasks(self) -> List[Task]:
        """ç”Ÿæˆå†…åœ¨ä»»åŠ¡ï¼ˆå†…åŠ¡ç®¡ç†ï¼‰"""

        tasks = []

        try:
            # æ£€æŸ¥æ˜¯å¦éœ€è¦æ•´ç†è®°å¿†
            if await self._should_organize_memory():
                tasks.append(Task(
                    id=str(uuid.uuid4()),
                    type="memory_organization",
                    description="æ•´ç†å’Œæ€»ç»“è®°å¿†",
                    priority=2,
                    source="internal",
                    requires_user_interaction=False,
                    timeout=300,  # 5åˆ†é’Ÿè¶…æ—¶
                    metadata={"task_type": "maintenance"}
                ))

            # æ£€æŸ¥æ˜¯å¦éœ€è¦å¥åº·æ£€æŸ¥
            if await self._should_health_check():
                tasks.append(Task(
                    id=str(uuid.uuid4()),
                    type="health_check",
                    description="ç³»ç»Ÿå¥åº·æ£€æŸ¥",
                    priority=1,
                    source="internal",
                    requires_user_interaction=False,
                    timeout=60,
                    metadata={"task_type": "maintenance"}
                ))

        except Exception as e:
            logger.error(f"å†…åœ¨ä»»åŠ¡ç”Ÿæˆå¤±è´¥: {e}")

        return tasks

    async def _should_organize_memory(self) -> bool:
        """åˆ¤æ–­æ˜¯å¦éœ€è¦æ•´ç†è®°å¿†"""
        # ç®€åŒ–å®ç°ï¼šæ¯å¤©å‡Œæ™¨3ç‚¹æ•´ç†
        now = datetime.now()
        if now.hour == 3 and now.minute < 5:
            # æ£€æŸ¥ä»Šå¤©æ˜¯å¦å·²ç»æ•´ç†è¿‡
            last_organized = await self.task_database.get_last_internal_task("memory_organization")
            if not last_organized or (now - last_organized.created_at).days >= 1:
                return True
        return False

    async def _should_health_check(self) -> bool:
        """åˆ¤æ–­æ˜¯å¦éœ€è¦å¥åº·æ£€æŸ¥"""
        # æ¯å°æ—¶æ£€æŸ¥ä¸€æ¬¡
        now = time.time()
        last_check = getattr(self, '_last_health_check', 0)

        if now - last_check >= 3600:
            self._last_health_check = now
            return True

        return False

    async def _check_system_health(self):
        """æ£€æŸ¥ç³»ç»Ÿå¥åº·"""

        try:
            # 1. è·å–ç³»ç»Ÿç›‘æ§æ•°æ®
            metrics = await self.system_monitor.get_metrics()

            logger.debug(
                f"ç³»ç»Ÿç›‘æ§: CPU={metrics.cpu_usage}%, "
                f"å†…å­˜={metrics.memory_usage}MB"
            )

            # 2. æ£€æŸ¥TaskAgentæ˜¯å¦å­˜æ´»
            for agent_id, agent in list(self.task_agents.items()):
                if not agent.is_alive():
                    logger.warning(f"TaskAgent {agent_id} å¼‚å¸¸é€€å‡ºï¼Œæ­£åœ¨é‡å¯...")
                    await self._restart_task_agent(agent_id)

            # 3. æ¸…ç†åƒµå°¸WorkerAgent
            await self._cleanup_zombie_workers()

        except Exception as e:
            logger.error(f"ç³»ç»Ÿå¥åº·æ£€æŸ¥å¼‚å¸¸: {e}")

    async def _restart_task_agent(self, agent_id: str):
        """é‡å¯TaskAgent"""

        try:
            old_agent = self.task_agents.get(agent_id)
            if old_agent:
                await old_agent.stop()
                del self.task_agents[agent_id]

            # åˆ›å»ºæ–°çš„TaskAgent
            new_agent = TaskAgent(
                id=agent_id,
                config=self.config,
                task_database=self.task_database,
                master_agent=self
            )

            await new_agent.start()
            self.task_agents[agent_id] = new_agent

            logger.info(f"TaskAgent {agent_id} å·²é‡å¯")

        except Exception as e:
            logger.error(f"é‡å¯TaskAgent {agent_id} å¤±è´¥: {e}")

    async def _cleanup_zombie_workers(self):
        """æ¸…ç†åƒµå°¸WorkerAgent"""

        now = time.time()
        zombie_ids = []

        for worker_id, worker_info in list(self.worker_agents.items()):
            # æ£€æŸ¥æ˜¯å¦è¶…æ—¶
            if now - worker_info.last_heartbeat > 600:  # 10åˆ†é’Ÿæ— å¿ƒè·³
                logger.warning(f"WorkerAgent {worker_id} è¶…æ—¶ï¼Œæ¸…ç†ä¸­...")
                zombie_ids.append(worker_id)

            # æ£€æŸ¥TaskAgentæ˜¯å¦è¿˜å¼•ç”¨è¿™ä¸ªWorker
            if not self._is_worker_referenced(worker_id):
                del self.worker_agents[worker_id]

    def _is_worker_referenced(self, worker_id: str) -> bool:
        """æ£€æŸ¥Workeræ˜¯å¦è¢«TaskAgentå¼•ç”¨"""
        for task_agent in self.task_agents.values():
            if worker_id in task_agent.worker_agents:
                return True
        return False

    async def stop(self):
        """åœæ­¢ä¸»Agent"""
        logger.info("Master Agent åœæ­¢ä¸­...")
        self.state = AgentState.STOPPING

        # åœæ­¢æ‰€æœ‰TaskAgent
        for agent in list(self.task_agents.values()):
            await agent.stop()

        # åœæ­¢ç»„ä»¶
        await self.perception_manager.stop()
        await self.system_monitor.stop()

        self.state = AgentState.STOPPED
        logger.info("Master Agent å·²åœæ­¢")
```

---

## 2. Task Databaseï¼ˆä»»åŠ¡æ•°æ®åº“ï¼‰

### æ•°æ®åº“ç»“æ„

```python
class TaskStatus(Enum):
    """ä»»åŠ¡çŠ¶æ€"""
    PENDING = "pending"          # å¾…å¤„ç†
    PROCESSING = "processing"    # å¤„ç†ä¸­
    COMPLETED = "completed"      # å·²å®Œæˆ
    FAILED = "failed"           # å¤±è´¥
    TIMEOUT = "timeout"         # è¶…æ—¶
    CANCELLED = "cancelled"      # å·²å–æ¶ˆ


@dataclass
class Task:
    """ä»»åŠ¡"""
    id: str                          # ä»»åŠ¡ID
    type: str                        # ä»»åŠ¡ç±»å‹
    description: str                 # ä»»åŠ¡æè¿°
    priority: int                    # ä¼˜å…ˆçº§ï¼ˆ0-5ï¼‰
    status: TaskStatus               # ä»»åŠ¡çŠ¶æ€
    source: str                      # ä»»åŠ¡æ¥æºï¼ˆuser/internal/eventï¼‰
    requires_user_interaction: bool # æ˜¯å¦éœ€è¦ç”¨æˆ·äº¤äº’
    timeout: Optional[int]           # æ€»è¶…æ—¶æ—¶é—´ï¼ˆç§’ï¼‰
    created_at: float                # åˆ›å»ºæ—¶é—´
    updated_at: float                # æ›´æ–°æ—¶é—´
    scheduled_at: Optional[float]    # è®¡åˆ’æ‰§è¡Œæ—¶é—´
    parent_id: Optional[str]         # çˆ¶ä»»åŠ¡ID
    metadata: Dict = None             # é¢å¤–å…ƒæ•°æ®

    # è¾“å…¥æ•°æ®
    input_data: Any = None


@dataclass
class SubTask:
    """å­ä»»åŠ¡"""
    id: str                          # å­ä»»åŠ¡ID
    parent_id: str                   # çˆ¶ä»»åŠ¡ID
    description: str                 # å­ä»»åŠ¡æè¿°
    tool_name: str                   # å·¥å…·åç§°
    memory_required: List[str]      # éœ€è¦çš„è®°å¿†
    input_data: Any                  # è¾“å…¥æ•°æ®
    status: TaskStatus               # çŠ¶æ€
    result: Optional[Any]            # æ‰§è¡Œç»“æœ
    error: Optional[str]             # é”™è¯¯ä¿¡æ¯
    timeout: Optional[int]           # è¶…æ—¶æ—¶é—´ï¼ˆç§’ï¼‰
    retry_count: int = 0             # é‡è¯•æ¬¡æ•°
    max_retries: int = 3             # æœ€å¤§é‡è¯•æ¬¡æ•°
    depends_on: List[int] = None     # ä¾èµ–çš„å­ä»»åŠ¡ç´¢å¼•åˆ—è¡¨
    created_at: float = None          # åˆ›å»ºæ—¶é—´
    completed_at: Optional[float] = None  # å®Œæˆæ—¶é—´


class TaskDatabase:
    """ä»»åŠ¡æ•°æ®åº“"""

    def __init__(self, config: dict):
        self.db_path = config.get("db_path", "./data/tasks.db")
        self.db = None
        self.max_retries = config.get("max_retries", 3)

    async def initialize(self):
        """åˆå§‹åŒ–æ•°æ®åº“"""
        self.db = await aiosqlite.connect(self.db_path)
        await self._create_tables()

    async def _create_tables(self):
        """åˆ›å»ºè¡¨ç»“æ„"""

        # ä»»åŠ¡è¡¨
        await self.db.execute("""
            CREATE TABLE IF NOT EXISTS tasks (
                id TEXT PRIMARY KEY,
                type TEXT NOT NULL,
                description TEXT NOT NULL,
                priority INTEGER NOT NULL,
                status TEXT NOT NULL,
                source TEXT NOT NULL,
                requires_user_interaction INTEGER DEFAULT 0,
                timeout INTEGER,
                created_at REAL NOT NULL,
                updated_at REAL NOT NULL,
                scheduled_at REAL,
                parent_id TEXT,
                input_data TEXT,
                metadata TEXT,
                FOREIGN KEY (parent_id) REFERENCES tasks(id)
            )
        """)

        # å­ä»»åŠ¡è¡¨
        await self.db.execute("""
            CREATE TABLE IF NOT EXISTS subtasks (
                id TEXT PRIMARY KEY,
                parent_id TEXT NOT NULL,
                description TEXT NOT NULL,
                tool_name TEXT NOT NULL,
                memory_required TEXT,
                input_data TEXT,
                status TEXT NOT NULL,
                result TEXT,
                error TEXT,
                timeout INTEGER,
                retry_count INTEGER DEFAULT 0,
                max_retries INTEGER DEFAULT 3,
                depends_on TEXT,
                created_at REAL NOT NULL,
                completed_at REAL,
                FOREIGN KEY (parent_id) REFERENCES tasks(id)
            )
        """)

        # ç´¢å¼•
        await self.db.execute("""
            CREATE INDEX IF NOT EXISTS idx_tasks_status
            ON tasks(status)
        """)

        await self.db.execute("""
            CREATE INDEX IF NOT EXISTS idx_tasks_priority
            ON tasks(priority DESC, created_at ASC)
        """)

        await self.db.execute("""
            CREATE INDEX IF NOT EXISTS idx_subtasks_status
            ON subtasks(status)
        """)

    async def add(self, task: Task) -> str:
        """æ·»åŠ ä»»åŠ¡"""
        await self.db.execute(
            """INSERT INTO tasks (
                id, type, description, priority, status, source,
                requires_user_interaction, timeout, created_at, updated_at,
                input_data, metadata, parent_id, scheduled_at
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)""",
            (
                task.id, task.type, task.description,
                task.priority, task.status.value,
                task.source, int(task.requires_user_interaction),
                task.timeout, task.created_at, task.updated_at,
                json.dumps(task.input_data) if task.input_data else None,
                json.dumps(task.metadata) if task.metadata else None,
                task.parent_id, task.scheduled_at
            )
        )
        return task.id

    async def get_pending_tasks(self) -> List[Task]:
        """è·å–å¾…å¤„ç†ä»»åŠ¡"""
        cursor = await self.db.execute("""
            SELECT * FROM tasks
            WHERE status = 'pending'
            ORDER BY priority DESC, created_at ASC
            LIMIT 100
        """)

        rows = await cursor.fetchall()
        return [Task.from_row(row) for row in rows]

    async def update_status(
        self,
        task_id: str,
        status: TaskStatus,
        error: str = None
    ):
        """æ›´æ–°ä»»åŠ¡çŠ¶æ€"""
        await self.db.execute(
            """UPDATE tasks SET status = ?, updated_at = ? WHERE id = ?""",
            (status.value, time.time(), task_id)
        )

    async def save_subtask_result(
        self,
        subtask_id: str,
        result: Any,
        success: bool
    ):
        """ä¿å­˜å­ä»»åŠ¡ç»“æœ"""
        if success:
            await self.db.execute(
                """UPDATE subtasks SET status = ?, result = ?, completed_at = ? WHERE id = ?""",
                (TaskStatus.COMPLETED.value, json.dumps(result), time.time(), subtask_id)
            )
        else:
            await self.db.execute(
                """UPDATE subtasks SET status = ?, completed_at = ? WHERE id = ?""",
                (TaskStatus.FAILED.value, time.time(), subtask_id)
            )

    async def get_subtasks(self, parent_id: str) -> List[SubTask]:
        """è·å–ä»»åŠ¡çš„æ‰€æœ‰å­ä»»åŠ¡"""
        cursor = await self.db.execute(
            """SELECT * FROM subtasks WHERE parent_id = ? ORDER BY id""",
            (parent_id,)
        )

        rows = await cursor.fetchall()
        return [SubTask.from_row(row) for row in rows]

    async def get_last_internal_task(self, task_type: str) -> Optional[Task]:
        """è·å–æœ€è¿‘çš„å†…åœ¨ä»»åŠ¡"""
        cursor = await self.db.execute("""
            SELECT * FROM tasks
            WHERE source = 'internal' AND type = ?
            ORDER BY created_at DESC
            LIMIT 1
        """, (task_type,))

        row = await cursor.fetchone()
        return Task.from_row(row) if row else None
```

---

## 3. TaskAgentï¼ˆä»»åŠ¡Agentï¼‰

### æ ¸å¿ƒèŒè´£
1. **æ‰«æä»»åŠ¡æ•°æ®åº“**ï¼šå®šæœŸè·å–å¾…å¤„ç†ä»»åŠ¡
2. **ä»»åŠ¡æ‹†è§£**ï¼šå°†å¤æ‚ä»»åŠ¡æ‹†åˆ†ä¸ºå­ä»»åŠ¡
3. **å·¥å…·åŒ¹é…**ï¼šåˆ¤æ–­éœ€è¦ä»€ä¹ˆå·¥å…·å’Œè®°å¿†
4. **è¶…æ—¶æ§åˆ¶**ï¼šè®¡ç®—ä»»åŠ¡æ€»è¶…æ—¶æ—¶é—´
5. **Workerç®¡ç†**ï¼šåˆ›å»ºå’Œæ¸…ç†WorkerAgent

### å®Œæ•´å®ç°

```python
class TaskAgent:
    """ä»»åŠ¡Agent - ä»»åŠ¡è¯†åˆ«ä¸æ‹†è§£"""

    def __init__(
        self,
        id: str,
        config: AgentConfig,
        task_database: TaskDatabase,
        master_agent: 'MasterAgent'
    ):
        self.id = id
        self.config = config
        self.task_database = task_database
        self.master_agent = master_agent
        self.llm = config.llm

        # æ ¸å¿ƒç»„ä»¶
        self.tool_decision_engine = ToolDecisionEngine(config.llm)
        self.memory_store = config.memory_store
        self.tool_registry = config.tool_registry

        # ç®¡ç†çš„WorkerAgent
        self.worker_agents: Dict[str, WorkerAgent] = {}

        # è¿è¡Œæ ‡å¿—
        self.is_running = False

    async def start(self):
        """å¯åŠ¨ä»»åŠ¡Agent"""
        logger.info(f"TaskAgent {self.id} å¯åŠ¨ä¸­...")
        self.is_running = True

        # å¯åŠ¨ä»»åŠ¡æ‰«æå¾ªç¯
        asyncio.create_task(self._task_loop())

    async def stop(self):
        """åœæ­¢ä»»åŠ¡Agent"""
        logger.info(f"TaskAgent {self.id} åœæ­¢ä¸­...")
        self.is_running = False

        # åœæ­¢æ‰€æœ‰WorkerAgent
        for worker in list(self.worker_agents.values()):
            await worker.stop()

        self.worker_agents.clear()

    async def _task_loop(self):
        """ä»»åŠ¡å¾ªç¯"""
        while self.is_running:
            try:
                # 1. æ‰«æä»»åŠ¡æ•°æ®åº“
                tasks = await self.task_database.get_pending_tasks()

                if not tasks:
                    await asyncio.sleep(1)
                    continue

                # 2. å¤„ç†æ¯ä¸ªä»»åŠ¡
                for task in tasks:
                    if not self.is_running:
                        break

                    try:
                        await self._process_task(task)
                    except Exception as e:
                        logger.error(f"å¤„ç†ä»»åŠ¡ {task.id} å¤±è´¥: {e}")
                        await self.task_database.update_status(
                            task.id,
                            TaskStatus.FAILED,
                            error=str(e)
                        )

            except Exception as e:
                logger.error(f"TaskAgent {self.id} å¾ªç¯å¼‚å¸¸: {e}")
                await asyncio.sleep(5)

    async def _process_task(self, task: Task):
        """å¤„ç†ä»»åŠ¡"""

        logger.info(f"å¤„ç†ä»»åŠ¡: {task.id} - {task.description}")

        # 1. æ›´æ–°ä»»åŠ¡çŠ¶æ€ä¸ºå¤„ç†ä¸­
        await self.task_database.update_status(task.id, TaskStatus.PROCESSING)

        # 2. è®¡ç®—ä»»åŠ¡æ€»è¶…æ—¶æ—¶é—´
        total_timeout = await self._calculate_timeout(task)

        # 3. ä»»åŠ¡æ‹†è§£
        subtasks = await self._decompose_task(task)

        if len(subtasks) == 0:
            # æ— æ³•æ‹†è§£ï¼Œç›´æ¥æ ‡è®°å®Œæˆ
            await self.task_database.update_status(task.id, TaskStatus.COMPLETED)
            return

        # 4. æ‰§è¡Œå­ä»»åŠ¡
        try:
            await asyncio.wait_for(
                self._execute_subtasks(subtasks),
                timeout=total_timeout
            )
            await self.task_database.update_status(task.id, TaskStatus.COMPLETED)

        except asyncio.TimeoutError:
            logger.warning(f"ä»»åŠ¡ {task.id} è¶…æ—¶ï¼Œæ‰§è¡Œå…œåº•æµç¨‹")
            await self._handle_task_timeout(task, subtasks)

        except Exception as e:
            logger.error(f"ä»»åŠ¡ {task.id} æ‰§è¡Œå¼‚å¸¸: {e}")
            await self.task_database.update_status(
                task.id,
                TaskStatus.FAILED,
                error=str(e)
            )

    async def _calculate_timeout(self, task: Task) -> int:
        """è®¡ç®—ä»»åŠ¡æ€»è¶…æ—¶æ—¶é—´"""

        # åŸºç¡€è¶…æ—¶
        base_timeout = 300  # 5åˆ†é’Ÿ

        # æ ¹æ®ä¼˜å…ˆçº§è°ƒæ•´
        priority_multiplier = {
            0: 2.0,  # æœ€ä½ä¼˜å…ˆçº§ï¼Œæœ€é•¿è¶…æ—¶
            1: 1.5,
            2: 1.0,
            3: 0.8,
            4: 0.5,
            5: 0.3   # æœ€é«˜ä¼˜å…ˆçº§ï¼Œæœ€çŸ­è¶…æ—¶
        }

        # æ ¹æ®æ˜¯å¦ç”¨æˆ·äº¤äº’è°ƒæ•´
        interaction_multiplier = 2.0 if task.requires_user_interaction else 1.0

        # æ ¹æ®ä»»åŠ¡ç±»å‹è°ƒæ•´
        type_multiplier = {
            "information_retrieval": 1.0,
            "communication": 1.5,
            "task_execution": 2.0,
            "memory_organization": 3.0,
        }

        timeout = base_timeout
        timeout *= priority_multiplier.get(task.priority, 1.0)
        timeout *= interaction_multiplier
        timeout *= type_multiplier.get(task.type, 1.0)

        return int(timeout)

    async def _decompose_task(self, task: Task) -> List[SubTask]:
        """æ‹†è§£ä»»åŠ¡"""

        try:
            # è·å–å¯ç”¨å·¥å…·
            available_tools = self.tool_registry.list_public()

            prompt = f"""
            ä»»åŠ¡æè¿°ï¼š{task.description}
            ä»»åŠ¡ç±»å‹ï¼š{task.type}
            ä»»åŠ¡è¾“å…¥ï¼š{task.input_data}

            å¯ç”¨å·¥å…·ï¼š
            {[f"{t.name}: {t.description}" for t in available_tools]}

            è¯·å°†ä»»åŠ¡æ‹†è§£ä¸ºå­ä»»åŠ¡ï¼š
            1. æ¯ä¸ªå­ä»»åŠ¡éœ€è¦ä»€ä¹ˆå·¥å…·
            2. æ¯ä¸ªå­ä»»åŠ¡éœ€è¦ä»€ä¹ˆè®°å¿†ï¼ˆä¸Šä¸‹æ–‡ï¼‰
            3. å­ä»»åŠ¡ä¹‹é—´çš„ä¾èµ–å…³ç³»ï¼ˆæ•°ç»„ç´¢å¼•ï¼‰

            æ ¼å¼ï¼šJSON
            [
                {{
                    "description": "æœç´¢æœ€æ–°AIæ–°é—»",
                    "tool": "web_search",
                    "memory": ["user_preferences", "search_history"],
                    "input": {{"query": "AI news"}},
                    "depends_on": [],
                    "timeout": 30
                }},
                {{
                    "description": "æ€»ç»“æ–°é—»å†…å®¹",
                    "tool": "summarize",
                    "memory": ["search_results"],
                    "input": {{}},
                    "depends_on": [0],
                    "timeout": 60
                }}
            ]
            """

            response = await self.llm.generate(prompt)
            subtask_data = json.loads(response)

            subtasks = []
            for i, data in enumerate(subtask_data):
                subtasks.append(SubTask(
                    id=f"{task.id}_sub_{i}",
                    parent_id=task.id,
                    description=data["description"],
                    tool_name=data["tool"],
                    memory_required=data.get("memory", []),
                    input_data=data.get("input", {}),
                    depends_on=data.get("depends_on", []),
                    timeout=data.get("timeout", 60),
                    created_at=time.time()
                ))

            return subtasks

        except Exception as e:
            logger.error(f"ä»»åŠ¡æ‹†è§£å¤±è´¥: {e}")
            return []

    async def _execute_subtasks(self, subtasks: List[SubTask]):
        """æ‰§è¡Œå­ä»»åŠ¡ï¼ˆæ”¯æŒå¹¶è¡Œï¼‰"""

        # æ„å»ºDAG
        dag = self._build_dag(subtasks)

        # æ‹“æ‰‘æ’åºæ‰§è¡Œ
        for subtask in dag.topological_sort():
            # æ£€æŸ¥ä¾èµ–æ˜¯å¦æ»¡è¶³
            if not self._dependencies_satisfied(subtask, subtasks):
                logger.warning(f"å­ä»»åŠ¡ {subtask.id} ä¾èµ–æœªæ»¡è¶³ï¼Œç­‰å¾…...")
                await asyncio.sleep(1)
                continue

            # åˆ›å»ºWorkerAgentæ‰§è¡Œ
            worker = WorkerAgent(
                id=subtask.id,
                config=self.config,
                tool_registry=self.tool_registry,
                memory_store=self.memory_store
            )

            self.worker_agents[subtask.id] = worker

            # æ‰§è¡Œï¼ˆå¸¦è¶…æ—¶ï¼‰
            try:
                result = await asyncio.wait_for(
                    worker.execute(subtask),
                    timeout=subtask.timeout
                )

                # ä¿å­˜ç»“æœ
                await self.task_database.save_subtask_result(
                    subtask.id, result, True
                )

            except asyncio.TimeoutError:
                logger.warning(f"å­ä»»åŠ¡ {subtask.id} è¶…æ—¶ï¼Œé‡è¯•ä¸­...")
                await self._retry_subtask(subtask)

            finally:
                # ç”¨å®Œå³é”€æ¯
                await worker.stop()
                del self.worker_agents[subtask.id]

    def _build_dag(self, subtasks: List[SubTask]) -> 'DAG':
        """æ„å»ºä»»åŠ¡DAG"""
        return DAG(subtasks)

    def _dependencies_satisfied(self, subtask: SubTask, all_subtasks: List[SubTask]) -> bool:
        """æ£€æŸ¥ä¾èµ–æ˜¯å¦æ»¡è¶³"""
        if not subtask.depends_on:
            return True

        # æ£€æŸ¥æ‰€æœ‰ä¾èµ–æ˜¯å¦å®Œæˆ
        for dep_idx in subtask.depends_on:
            dep_subtask = all_subtasks[dep_idx]
            if dep_subtask.status != TaskStatus.COMPLETED:
                return False

        return True

    async def _retry_subtask(self, subtask: SubTask):
        """é‡è¯•å­ä»»åŠ¡"""

        if subtask.retry_count >= subtask.max_retries:
            logger.error(f"å­ä»»åŠ¡ {subtask.id} é‡è¯•æ¬¡æ•°è€—å°½")
            await self.task_database.save_subtask_result(
                subtask.id, None, False
            )
            return

        subtask.retry_count += 1

        # åˆ›å»ºæ–°çš„WorkerAgentæ‰§è¡Œ
        worker = WorkerAgent(
            id=f"{subtask.id}_retry_{subtask.retry_count}",
            config=self.config,
            tool_registry=self.tool_registry,
            memory_store=self.memory_store
        )

        try:
            result = await asyncio.wait_for(
                worker.execute(subtask),
                timeout=subtask.timeout
            )

            await self.task_database.save_subtask_result(
                subtask.id, result, True
            )

        finally:
            await worker.stop()

    async def _handle_task_timeout(self, task: Task, subtasks: List[SubTask]):
        """å¤„ç†ä»»åŠ¡è¶…æ—¶ - å…œåº•æµç¨‹"""

        logger.warning(f"ä»»åŠ¡ {task.id} è¶…æ—¶ï¼Œæ‰§è¡Œå…œåº•æµç¨‹")

        # ç­–ç•¥1ï¼šå…³é—­è¶…æ—¶çš„WorkerAgent
        for worker_id, worker in list(self.worker_agents.items()):
            if worker.is_busy():
                await worker.stop()
                del self.worker_agents[worker_id]

        # ç­–ç•¥2ï¼šåˆ›å»ºæ–°çš„TaskAgenté‡æ–°æ‰§è¡Œ
        # ä½¿ç”¨æ›´é•¿çš„è¶…æ—¶æ—¶é—´
        fallback_task = Task(
            id=f"{task.id}_fallback",
            type=task.type,
            description=f"{task.description}ï¼ˆå…œåº•ï¼‰",
            priority=max(task.priority - 1, 0),
            source="fallback",
            requires_user_interaction=False,
            timeout=task.timeout * 2,  # åŒå€è¶…æ—¶
            input_data=task.input_data
        )

        await self.task_database.add(fallback_task)

    def is_alive(self) -> bool:
        """æ£€æŸ¥Agentæ˜¯å¦å­˜æ´»"""
        return self.is_running
```

---

## 4. WorkerAgentï¼ˆå­Agentï¼‰

### æ ¸å¿ƒè®¾è®¡åŸåˆ™
- **æ— çŠ¶æ€**ï¼šæ¯æ¬¡æ‰§è¡Œå®Œå°±å¯ä»¥é”€æ¯
- **è½»é‡çº§**ï¼šæœ€å°åŒ–ä¾èµ–å’Œåˆå§‹åŒ–
- **ç‹¬ç«‹è¶…æ—¶**ï¼šæ¯ä¸ªWorkeræœ‰ç‹¬ç«‹çš„è¶…æ—¶æ§åˆ¶
- **å¹‚ç­‰æ€§æ”¯æŒ**ï¼šå¤–éƒ¨ç³»ç»Ÿè°ƒç”¨éœ€è¦å¹‚ç­‰

### å®Œæ•´å®ç°

```python
class WorkerAgent:
    """Worker Agent - æ— çŠ¶æ€æ‰§è¡Œå•å…ƒ"""

    def __init__(
        self,
        id: str,
        config: AgentConfig,
        tool_registry: ToolRegistry,
        memory_store: MemoryStore
    ):
        self.id = id
        self.config = config
        self.tool_registry = tool_registry
        self.memory_store = memory_store
        self.is_busy = False

    async def execute(self, subtask: SubTask) -> WorkerResult:
        """æ‰§è¡Œå­ä»»åŠ¡"""
        self.is_busy = True

        try:
            logger.info(f"WorkerAgent {self.id} æ‰§è¡Œå­ä»»åŠ¡: {subtask.description}")

            # 1. ä»è®°å¿†åŠ è½½ä¸Šä¸‹æ–‡
            context = await self._load_context(subtask.memory_required)

            # 2. åˆå¹¶è¾“å…¥æ•°æ®
            full_input = {**context, **subtask.input_data}

            # 3. æ‰§è¡Œå·¥å…·ï¼ˆæ”¯æŒå¹‚ç­‰ï¼‰
            result = await self._execute_tool_idempotent(
                subtask.tool_name,
                full_input
            )

            return WorkerResult(
                worker_id=self.id,
                success=result.success,
                data=result.data,
                error=result.error
            )

        finally:
            self.is_busy = False

    async def _load_context(self, memory_keys: List[str]) -> Dict:
        """ä»è®°å¿†åŠ è½½ä¸Šä¸‹æ–‡"""

        context = {}
        for key in memory_keys:
            try:
                # ä»è®°å¿†ä¸­æ£€ç´¢
                memories = await self.memory_store.recall(key, top_k=5)
                context[key] = memories
            except Exception as e:
                logger.warning(f"åŠ è½½è®°å¿† {key} å¤±è´¥: {e}")
                context[key] = []

        return context

    async def _execute_tool_idempotent(
        self,
        tool_name: str,
        params: dict
    ) -> ToolResult:
        """æ‰§è¡Œå·¥å…·ï¼ˆæ”¯æŒå¹‚ç­‰ï¼‰"""

        tool = self.tool_registry.get(tool_name)
        if not tool:
            raise ValueError(f"å·¥å…·ä¸å­˜åœ¨: {tool_name}")

        # å¹‚ç­‰æ€§æ£€æŸ¥
        if await self._is_idempotent(tool):
            params = await self._ensure_idempotency(tool, params)

        # æ‰§è¡Œå·¥å…·
        result = await tool.execute(params)

        return result

    async def _is_idempotent(self, tool: Tool) -> bool:
        """åˆ¤æ–­å·¥å…·æ˜¯å¦éœ€è¦å¹‚ç­‰"""
        # æ£€æŸ¥å·¥å…·å…ƒæ•°æ®
        return tool.metadata.get("idempotent", False)

    async def _ensure_idempotency(
        self,
        tool: Tool,
        params: dict
    ) -> dict:
        """ç¡®ä¿å¹‚ç­‰æ€§"""

        # ç­–ç•¥1ï¼šæ·»åŠ idempotency_key
        if "idempotency_key" not in params:
            params["idempotency_key"] = str(uuid.uuid4())

        # ç­–ç•¥2ï¼šæ£€æŸ¥æ˜¯å¦å·²æ‰§è¡Œ
        executed = await self._check_executed(tool.name, params)
        if executed:
            logger.info(f"å·¥å…· {tool.name} å·²æ‰§è¡Œï¼Œè¿”å›ç¼“å­˜ç»“æœ")
            return executed

        # è®°å½•æ‰§è¡ŒçŠ¶æ€
        await self._mark_executed(tool.name, params)

        return params

    async def _check_executed(self, tool_name: str, params: dict) -> Optional[Any]:
        """æ£€æŸ¥æ˜¯å¦å·²æ‰§è¡Œï¼ˆä»ç¼“å­˜ï¼‰"""
        # ç®€åŒ–å®ç°ï¼šå¯ä»¥ä»å†…å­˜ç¼“å­˜æˆ–Redisæ£€æŸ¥
        return None

    async def _mark_executed(self, tool_name: str, params: dict):
        """æ ‡è®°å·²æ‰§è¡Œ"""
        # è®°å½•åˆ°ç¼“å­˜ï¼Œè®¾ç½®TTL
        pass

    async def stop(self):
        """åœæ­¢WorkerAgent"""
        logger.info(f"WorkerAgent {self.id} åœæ­¢")
        # æ— çŠ¶æ€ï¼Œç›´æ¥è¿”å›
```

---

## 5. ç³»ç»Ÿç›‘æ§ï¼ˆç®€å•å®ç°ï¼‰

```python
class SystemMonitor:
    """ç³»ç»Ÿç›‘æ§"""

    def __init__(self):
        self.is_running = False

    async def start(self):
        """å¯åŠ¨ç›‘æ§"""
        self.is_running = True
        asyncio.create_task(self._monitor_loop())

    async def _monitor_loop(self):
        """ç›‘æ§å¾ªç¯"""
        while self.is_running:
            # æ¯ç§’é‡‡é›†ä¸€æ¬¡
            await asyncio.sleep(1)

    async def get_metrics(self) -> SystemMetrics:
        """è·å–ç³»ç»ŸæŒ‡æ ‡"""
        import psutil

        return SystemMetrics(
            cpu_usage=psutil.cpu_percent(),
            memory_usage=psutil.virtual_memory().used / (1024 * 1024),  # MB
            timestamp=time.time()
        )


@dataclass
class SystemMetrics:
    cpu_usage: float      # CPUä½¿ç”¨ç‡ï¼ˆ%ï¼‰
    memory_usage: float   # å†…å­˜ä½¿ç”¨ï¼ˆMBï¼‰
    timestamp: float
```

---

## 6. é…ç½®æ–‡ä»¶

```yaml
# config/agent.yaml
agent:
  # ä¸»Agenté…ç½®
  master:
    num_task_agents: 3    # TaskAgentå›ºå®šæ•°é‡

  # TaskAgenté…ç½®
  task_agent:
    scan_interval: 1      # æ‰«æä»»åŠ¡é—´éš”ï¼ˆç§’ï¼‰
    max_concurrent_tasks: 5 # å¹¶å‘å¤„ç†ä»»åŠ¡æ•°

  # WorkerAgenté…ç½®
  worker_agent:
    max_retries: 3        # æœ€å¤§é‡è¯•æ¬¡æ•°
    default_timeout: 60   # é»˜è®¤è¶…æ—¶ï¼ˆç§’ï¼‰

  # LLMé…ç½®
  llm:
    provider: "openai"
    model: "gpt-4"
    api_key: "${OPENAI_API_KEY}"
    timeout: 30

  # è®°å¿†é…ç½®
  memory:
    short_term: "memory"
    long_term: "chromadb"

  # æ„ŸçŸ¥å™¨é…ç½®
  perception:
    microphone:
      enabled: false
    email:
      enabled: true
      imap_server: "imap.gmail.com"
      username: "${EMAIL_ADDRESS}"
      password: "${EMAIL_PASSWORD}"
    file_monitor:
      enabled: true
      watch_paths:
        - "/path/to/watch"

  # ä»»åŠ¡æ•°æ®åº“é…ç½®
  database:
    db_path: "./data/tasks.db"
    max_retries: 3
```

---

## 7. ç›®å½•ç»“æ„

```
magi/backend/src/magi/core/
â”œâ”€â”€ __init__.py
â”œâ”€â”€ agent.py              # AgentåŸºç±»
â”œâ”€â”€ master.py            # Master Agent
â”œâ”€â”€ task_agent.py        # Task Agent
â”œâ”€â”€ worker_agent.py      # Worker Agent
â”œâ”€â”€ state.py             # AgentçŠ¶æ€å®šä¹‰
â”œâ”€â”€ tasks/
â”‚   â”œâ”€â”€ database.py       # ä»»åŠ¡æ•°æ®åº“
â”‚   â”œâ”€â”€ task.py          # ä»»åŠ¡æ¨¡å‹
â”‚   â””â”€â”€ dag.py           # ä»»åŠ¡DAG
â””â”€â”€ monitoring/
    â”œâ”€â”€ monitor.py        # ç³»ç»Ÿç›‘æ§
    â””â”€â”€ metrics.py        # ç›‘æ§æŒ‡æ ‡
```

---

## âœ… æ ¸å¿ƒç‰¹æ€§æ€»ç»“

### MasterAgentï¼ˆç¬¬ä¸€å±‚ï¼‰
- âœ… ä»»åŠ¡è¯†åˆ«ï¼ˆç”¨æˆ·/äº‹ä»¶/å†…åœ¨ï¼‰
- âœ… ç³»ç»Ÿç›‘æ§ï¼ˆCPU/å†…å­˜ï¼‰
- âœ… Agentå¥åº·æ£€æŸ¥å’Œè‡ªæ„ˆ
- âœ… å›ºå®šæ•°é‡TaskAgentï¼ˆé…ç½®åŒ–ï¼‰
- âœ… ä»»åŠ¡æ•°æ®åº“ç®¡ç†

### TaskAgentï¼ˆç¬¬äºŒå±‚ï¼‰
- âœ… æ‰«æä»»åŠ¡æ•°æ®åº“
- âœ… ä»»åŠ¡æ‹†è§£ï¼ˆLLMå†³ç­–ï¼‰
- âœ… å·¥å…·å’Œè®°å¿†åŒ¹é…
- âœ… å­ä»»åŠ¡DAGç¼–æ’
- âœ… æ€»è¶…æ—¶æ§åˆ¶ï¼ˆæ ¹æ®ç±»å‹/ä¼˜å…ˆçº§/äº¤äº’ï¼‰
- âœ… WorkerAgentç”Ÿå‘½å‘¨æœŸç®¡ç†
- âœ… è¶…æ—¶å…œåº•æœºåˆ¶

### WorkerAgentï¼ˆç¬¬ä¸‰å±‚ï¼‰
- âœ… æ— çŠ¶æ€ã€è½»é‡çº§
- âœ… ç”¨å®Œå³é”€æ¯
- âœ… ç‹¬ç«‹è¶…æ—¶æ§åˆ¶
- âœ… å¹‚ç­‰æ€§æ”¯æŒ

### ä»»åŠ¡æ•°æ®åº“
- âœ… æŒä¹…åŒ–ä»»åŠ¡é˜Ÿåˆ—
- âœ… å­ä»»åŠ¡ç®¡ç†
- âœ… çŠ¶æ€è·Ÿè¸ª
- âœ… SQLiteå­˜å‚¨

### ç³»ç»Ÿç›‘æ§
- âœ… CPU/å†…å­˜ç›‘æ§
- âœ… ç®€å•å®ç°ï¼ˆpsutilï¼‰

---

## ğŸ“Š å®Œæ•´æ‰§è¡Œæµç¨‹

```
ç”¨æˆ·è¾“å…¥ â†’ MasterAgentæ„ŸçŸ¥ â†’ è¯†åˆ«ä¸ºç”¨æˆ·ä»»åŠ¡
    â†“
å†™å…¥ä»»åŠ¡æ•°æ®åº“
    â†“
TaskAgentæ‰«ææ•°æ®åº“ â†’ è·å–ä»»åŠ¡
    â†“
ä»»åŠ¡æ‹†è§£ï¼ˆLLMï¼‰â†’ ç”Ÿæˆå­ä»»åŠ¡
    â†“
åˆ›å»ºWorkerAgentæ‰§è¡Œå­ä»»åŠ¡
    â†“
WorkerAgentæ‰§è¡Œå·¥å…· â†’ è¿”å›ç»“æœ
    â†“
ç»“æœå†™å…¥æ•°æ®åº“
    â†“
MasterAgentç›‘æ§ç³»ç»Ÿå¥åº·
```

---

è¿™ä¸ªè®¾è®¡ç¬¦åˆä½ çš„æƒ³æ³•å—ï¼Ÿæœ‰éœ€è¦è°ƒæ•´çš„åœ°æ–¹å—ï¼Ÿ
